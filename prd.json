{
  "name": "OpenFifa",
  "branchName": "main",
  "description": "5v5 AAA arcade-style soccer game for macOS & iPad, built with Unity 6 LTS + URP",
  "userStories": [
    {
      "id": "US-001",
      "title": "Unity project scaffold + macOS/iPad build pipeline + test framework",
      "description": "As a developer, I want a properly scaffolded Unity 6 LTS project with URP, macOS and iPad build pipelines, NUnit test framework, and CI-friendly .gitignore so that the team can begin development with a solid foundation.",
      "acceptanceCriteria": [
        "Unity 6 LTS project exists with Universal Render Pipeline (URP) configured as the active render pipeline",
        "URP Global Settings asset is assigned in Graphics Settings and Quality Settings",
        "Project builds to macOS .app target and iPad Simulator target via xcodebuild without errors",
        "NUnit test framework package (com.unity.test-framework) is installed and resolvable in manifest.json",
        "EditMode test assembly definition exists at Tests/Editor/EditModeTests.asmdef with testRunner set to Editor",
        "PlayMode test assembly definition exists at Tests/Runtime/PlayModeTests.asmdef with testRunner set to PlayMode",
        "A sample EditMode test class exists with at least one [Test] method that asserts true and passes",
        "A sample PlayMode test class exists with at least one [UnityTest] method that yields and passes",
        "Running 'unity -runTests -batchmode -nographics -testPlatform EditMode' exits with code 0",
        "Running 'unity -runTests -batchmode -nographics -testPlatform PlayMode' exits with code 0",
        ".gitignore covers Library/, Temp/, Obj/, Build/, Builds/, Logs/, UserSettings/, *.csproj, *.sln, *.pidb, *.unityproj, *.suo, *.user, *.apk, *.ipa",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 1,
      "passes": true,
      "notes": "Use Unity 6000.0 LTS. Create project via 'unity -createProject' or Unity Hub with 3D (URP) template. Install packages: com.unity.render-pipelines.universal, com.unity.test-framework. Create UniversalRenderPipelineAsset via ScriptableObject. For macOS build: BuildPipeline.BuildPlayer with BuildTarget.StandaloneOSX. For iPad build: BuildPipeline.BuildPlayer with BuildTarget.iOS, then xcodebuild -project Unity-iPhone.xcodeproj -scheme Unity-iPhone -destination 'platform=iOS Simulator,name=iPad Pro 13-inch (M4)'.",
      "dependsOn": [],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-001'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-002",
      "title": "Soccer pitch with correct 5v5 proportions + boundary colliders",
      "description": "As a player, I want a correctly proportioned 5v5 soccer pitch with visible markings and boundary colliders so that the game feels like a real small-sided soccer match.",
      "acceptanceCriteria": [
        "A GameObject named 'Pitch' exists in the Match scene with a MeshRenderer using a green material",
        "Pitch dimensions are approximately 50m x 30m (x and z axes), verified by Renderer.bounds.size",
        "Four boundary colliders (BoxCollider) exist along the pitch perimeter preventing Rigidbody objects from exiting",
        "A ball spawned at center with velocity toward each boundary is stopped by the collider within the pitch bounds",
        "Center circle marking exists as a child object or decal at the pitch midpoint with radius ~3m",
        "Goal area markings exist on both ends of the pitch as child objects or decals",
        "Pitch configuration data (dimensions, goal width, center circle radius) is stored in a ScriptableObject named PitchConfig",
        "PitchConfig ScriptableObject fields are accessible and return expected values in EditMode test",
        "Goal openings exist in the boundary colliders at each end, sized to match goal width from PitchConfig",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Create PitchConfig : ScriptableObject with fields: pitchLength (50f), pitchWidth (30f), goalWidth (5f), centerCircleRadius (3f), goalAreaDepth (4f). Use a scaled Quad or Plane for the pitch surface. Boundary colliders should be thin BoxColliders positioned at edges. Mark center circle with a LineRenderer or projector decal. Use layers: 'Pitch' for ground, 'Boundary' for walls.",
      "dependsOn": ["US-001"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-002'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-003",
      "title": "Ball physics with realistic mass, bounce, friction, and rolling",
      "description": "As a player, I want the ball to behave realistically with proper mass, bounce, friction, and rolling so that gameplay feels satisfying and predictable.",
      "acceptanceCriteria": [
        "A GameObject named 'Ball' exists with a SphereCollider and Rigidbody component",
        "Rigidbody mass is set to 0.43 (kg), drag to 0.1, angularDrag to 0.5",
        "A PhysicMaterial is assigned to the SphereCollider with bounciness 0.6 and dynamicFriction 0.5",
        "When dropped from 2m height onto pitch, ball bounces to a height within restitution range 0.45-0.75 of drop height",
        "A rolling ball given initial velocity of 10 m/s comes to rest within 6-22m distance",
        "Ball cannot escape pitch boundaries when launched at 30 m/s toward any boundary wall",
        "Ball Rigidbody interpolation is set to Interpolate for smooth visual movement",
        "Ball collision detection mode is set to Continuous to prevent tunneling at high speeds",
        "Ball velocity can be read and applied via Rigidbody.linearVelocity in tests",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 3,
      "passes": true,
      "notes": "Create BallController : MonoBehaviour on the Ball GameObject. Use PhysicMaterial asset with bounceCombine = Average, frictionCombine = Average. Set Rigidbody.collisionDetectionMode = ContinuousDynamic. For tests, use Physics.simulationMode = Script and step with Physics.Simulate(Time.fixedDeltaTime) in PlayMode tests. Layer: 'Ball'. Tag: 'Ball'. Consider adding a BallState enum (Free, Possessed, InFlight).",
      "dependsOn": ["US-002"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-003'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-004",
      "title": "Single player controller with keyboard movement and sprint",
      "description": "As a player, I want to control a single character using keyboard input with movement and sprint so that I can navigate the pitch freely.",
      "acceptanceCriteria": [
        "A GameObject named 'Player' exists with a CapsuleCollider and Rigidbody component",
        "Player moves in the correct direction when WASD or arrow keys are pressed, verified by position delta in PlayMode test",
        "Holding Left Shift activates sprint mode at 1.5x base movement speed",
        "Player acceleration reaches top speed within 1-3 seconds from standstill, measured in PlayMode test",
        "Player movement input is normalized so diagonal movement does not exceed maximum speed",
        "Player cannot move beyond pitch boundary colliders in any direction",
        "Player Rigidbody uses constraints to freeze Y-axis rotation to prevent tipping",
        "PlayerController exposes a read-only 'IsSprinting' property that returns true during sprint",
        "PlayerController exposes a read-only 'CurrentSpeed' property returning current velocity magnitude",
        "Movement uses Unity Input System (com.unity.inputsystem) with a PlayerInput component or direct InputAction references",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 4,
      "passes": true,
      "notes": "Create PlayerController : MonoBehaviour. Use New Input System: create InputActionAsset with 'Player' action map containing Move (Vector2, WASD/Arrows composite) and Sprint (Button, LeftShift). Movement via Rigidbody.MovePosition or velocity-based. Base speed ~7 m/s, sprint ~10.5 m/s. Freeze rotation on X and Z axes via RigidbodyConstraints. Layer: 'Player'. Use [RequireComponent(typeof(Rigidbody))].",
      "dependsOn": ["US-002"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-004'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-005",
      "title": "Goal detection system with event broadcasting",
      "description": "As a player, I want the game to detect when a goal is scored by the ball fully crossing the goal line so that goals are accurately counted.",
      "acceptanceCriteria": [
        "Trigger collider volumes exist behind each goal line, spanning the full goal width and height",
        "An OnGoalScored event (C# event or UnityEvent) fires when the ball enters the trigger volume",
        "The event payload includes the scoring team identifier (TeamA or TeamB)",
        "A ball positioned exactly on the goal line does NOT trigger a goal",
        "A ball moved fully past the goal line DOES trigger exactly one goal event",
        "After goal detection, the ball is repositioned to the pitch center within 3 seconds",
        "GoalDetector component exposes a public event that external systems can subscribe to",
        "Goal detection works correctly for both goals (TeamA scores on TeamB's goal and vice versa)",
        "The goal trigger volume uses isTrigger = true and does not physically block the ball",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 5,
      "passes": true,
      "notes": "Create GoalDetector : MonoBehaviour with OnTriggerEnter(Collider). Place trigger BoxCollider behind each goal line (not on the line). Use a TeamIdentifier enum { TeamA, TeamB }. Fire event: public static event System.Action<TeamIdentifier> OnGoalScored. Use CompareTag('Ball') to filter triggers. For reset, start coroutine to wait then reposition. Consider using Physics.OverlapBox in tests to verify trigger placement.",
      "dependsOn": ["US-003"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-005'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-006",
      "title": "Broadcast camera with Cinemachine follow",
      "description": "As a player, I want a broadcast-style camera that smoothly follows the ball so that I can always see the action clearly.",
      "acceptanceCriteria": [
        "Cinemachine package (com.unity.cinemachine) is installed and a CinemachineCamera (or VirtualCamera) exists in the Match scene",
        "Camera follows the ball GameObject as its primary tracking target",
        "Camera is positioned at approximately 35 degrees elevation angle relative to the pitch plane",
        "Camera movement uses smooth damping so there are no jarring jumps when the ball moves quickly",
        "A CinemachineTargetGroup component tracks both the ball and the active player",
        "Camera frustum never clips through the pitch plane (camera Y position always > 0)",
        "Camera field of view or distance is configured to show a reasonable portion of the pitch at all times",
        "Camera smoothly transitions when the ball moves from one end to the other (no teleporting)",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 6,
      "passes": true,
      "notes": "Use Cinemachine 3.x (com.unity.cinemachine@3.0+). Create CinemachineCamera with Follow and LookAt targets. Use CinemachineFollow (Orbital Transposer replacement) with damping ~1s. Set body offset to achieve ~35 degree angle. CinemachineTargetGroup with Ball (weight 1.0) and ActivePlayer (weight 0.5). Test camera position with Camera.main.transform.position assertions. Ensure Cinemachine Brain is on Main Camera.",
      "dependsOn": ["US-002"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-006'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-007",
      "title": "Match timer + score tracking as pure C# logic",
      "description": "As a developer, I want match timer and score tracking implemented as pure C# classes so that they can be unit-tested without MonoBehaviour dependencies.",
      "acceptanceCriteria": [
        "MatchTimer class exists as a plain C# class (not MonoBehaviour) with a configurable half duration in seconds",
        "MatchTimer.Tick(float deltaTime) method decrements remaining time and transitions periods correctly",
        "MatchTimer tracks current period via enum: PreKickoff, FirstHalf, HalfTime, SecondHalf, FullTime",
        "MatchTimer transitions from FirstHalf to HalfTime when first half time reaches zero",
        "MatchTimer transitions from SecondHalf to FullTime when second half time reaches zero",
        "MatchScore class exists as a plain C# class tracking goals for TeamA and TeamB",
        "MatchScore.AddGoal(TeamIdentifier team) increments the correct team score",
        "MatchScore.GetScore(TeamIdentifier team) returns the current score for that team",
        "All MatchTimer and MatchScore logic is testable in EditMode tests without scene loading",
        "MatchTimer fires events (C# events) on period transitions",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 7,
      "passes": true,
      "notes": "Create MatchTimer and MatchScore as plain C# classes in a Runtime assembly. MatchTimer fields: float halfDuration, float remainingTime, MatchPeriod currentPeriod. Events: event Action<MatchPeriod> OnPeriodChanged. MatchScore: Dictionary<TeamIdentifier, int> or two int fields. No MonoBehaviour needed, making EditMode tests trivial. A MatchTimerBehaviour MonoBehaviour can wrap MatchTimer and call Tick(Time.deltaTime) in Update.",
      "dependsOn": ["US-005"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-007'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-008",
      "title": "Basic HUD displaying score and timer",
      "description": "As a player, I want to see the current score and match timer on screen so that I always know the game state.",
      "acceptanceCriteria": [
        "A Canvas with render mode Screen Space - Overlay exists in the Match scene",
        "TextMeshPro text element displays score in format 'TeamA 0 - 0 TeamB'",
        "TextMeshPro text element displays timer in format 'MM:SS' counting down",
        "Score text updates within the same frame when MatchScore changes",
        "Timer text updates every frame to reflect MatchTimer remaining time",
        "HUD elements are visible and not clipped at 1920x1080 reference resolution",
        "Canvas Scaler is configured with reference resolution 1920x1080 and 'Scale With Screen Size' mode",
        "TextMeshPro package (com.unity.textmeshpro) is installed and font assets are assigned",
        "HUD elements have RectTransform anchors set so they remain in correct positions across aspect ratios",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 8,
      "passes": true,
      "notes": "Create HUDController : MonoBehaviour referencing TMP_Text fields for score and timer. Subscribe to MatchScore and MatchTimer events or poll in Update. Use CanvasScaler with matchWidthOrHeight = 0.5. Format timer: TimeSpan.FromSeconds(remaining).ToString('mm\\:ss'). Anchor score to top-center, timer below it. Use TextMeshPro - Text (UI) components. Test by checking TMP_Text.text values after triggering score/timer changes.",
      "dependsOn": ["US-007"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-008'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-009",
      "title": "Team formation system with 2-1-2 layout",
      "description": "As a developer, I want a team formation system using ScriptableObjects so that player positions can be defined, queried, and swapped at runtime.",
      "acceptanceCriteria": [
        "A FormationData ScriptableObject class exists defining 5 named positions: GK, LB, CM, LW, RW (or similar 2-1-2 layout)",
        "Each position stores a local offset Vector3 relative to the team's defensive half center",
        "FormationData.GetPositions() returns a Vector3 array of length 5",
        "Positions are mirrored correctly for the opposing team (reflected across the pitch midline)",
        "A default 2-1-2 FormationData asset exists with sensible position offsets",
        "Formation positions can be read and verified in an EditMode test without scene loading",
        "A FormationManager component can swap the active FormationData at runtime and GetPositions reflects the change immediately",
        "Position roles are identified by an enum (e.g., PositionRole.Goalkeeper, Defender, Midfielder, Forward)",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 9,
      "passes": true,
      "notes": "Create FormationData : ScriptableObject with [System.Serializable] struct FormationSlot { PositionRole role; Vector3 offset; }. List<FormationSlot> slots. GetPositions(bool isHomeTeam, float pitchLength) mirrors offsets for away team by negating Z. Create FormationManager : MonoBehaviour to hold current formation reference and expose GetWorldPositions(). 2-1-2: GK(0,0,-12), LB(-6,0,-6), RB(6,0,-6), CM(0,0,0), LW(-6,0,8), RW(6,0,8) approximately.",
      "dependsOn": ["US-002"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-009'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-010",
      "title": "AI player finite state machine (idle, chase ball, return to position)",
      "description": "As a player, I want AI-controlled teammates and opponents that intelligently switch between idling, chasing the ball, and returning to formation so that the game feels competitive.",
      "acceptanceCriteria": [
        "AIController component implements a state machine with at least three states: Idle, ChaseBall, ReturnToPosition",
        "AI transitions to ChaseBall when ball is within a configurable range and the AI is the nearest team member to the ball",
        "AI transitions to ReturnToPosition when ball moves to a different pitch zone or another teammate is closer",
        "AI transitions to Idle when at formation position and ball is far away",
        "State transitions are logged via Debug.Log or a custom logger for debugging",
        "AI moves toward its target (ball or formation position) at a configurable speed",
        "AIController exposes a read-only CurrentState property returning the active state enum value",
        "In a PlayMode test, placing the ball near an AI player causes it to enter ChaseBall state within 1 second",
        "In a PlayMode test, moving the ball far away causes the AI to enter ReturnToPosition state",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 10,
      "passes": true,
      "notes": "Create AIController : MonoBehaviour with an AIState enum { Idle, ChaseBall, ReturnToPosition }. Use a simple switch-based FSM in Update. Transition logic: if nearest to ball and within chaseRange -> ChaseBall; if not nearest or ball far -> ReturnToPosition; if at formation pos within threshold -> Idle. Movement via Rigidbody.MovePosition or NavMeshAgent. Reference FormationManager for home position. Configurable: chaseRange (10f), moveSpeed (6f), positionThreshold (1f).",
      "dependsOn": ["US-004", "US-009"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-010'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-011",
      "title": "AI passing to detect open teammate and pass",
      "description": "As a player, I want AI players to identify open teammates and execute passes so that AI teams play coordinated soccer.",
      "acceptanceCriteria": [
        "AI evaluates teammate openness by calculating distance from each teammate to the nearest opponent",
        "AI selects the most open teammate (greatest distance to nearest opponent) as the pass target",
        "AI applies force to the ball directed toward the selected teammate's position",
        "A pass from AI reaches within 3m of the target teammate within 2 seconds in a controlled test scenario",
        "Pass accuracy is greater than 60% across 10 randomized test scenarios (ball arrives within 3m of target)",
        "AI only attempts a pass when it currently possesses the ball",
        "Pass force is scaled based on distance to target (further target = more force)",
        "AIPassingSystem exposes the last selected pass target for test verification",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 11,
      "passes": true,
      "notes": "Create AIPassingSystem : MonoBehaviour or integrate into AIController. Openness score = min distance from teammate to any opponent. Use Physics.Linecast to check for obstructions. Pass force: Rigidbody.AddForce((targetPos - ballPos).normalized * passForce, ForceMode.Impulse). passForce ~8-12 based on distance. Evaluate pass options in a coroutine or on a timer (every 0.5s) to avoid per-frame cost. Use [SerializeField] float passForceMultiplier.",
      "dependsOn": ["US-010", "US-003"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-011'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-012",
      "title": "AI shooting toward goal",
      "description": "As a player, I want AI players to detect shooting opportunities and shoot toward the goal so that matches produce goals and excitement.",
      "acceptanceCriteria": [
        "AI detects when it is within a configurable shooting range (default 15m) of the opponent goal",
        "AI checks for a clear line to the goal using Physics.Linecast (no defenders blocking)",
        "Shot applies force to the ball directed toward a point within the goal opening",
        "A shot from 15m reaches the goal plane within 0.8-1.5 seconds in a PlayMode test",
        "AI prefers shooting over passing when within shooting range and has a clear line",
        "Shot target varies slightly (not always dead center) to add unpredictability",
        "AIShootingSystem exposes whether a shot opportunity is currently available for test verification",
        "AI only attempts a shot when it currently possesses the ball",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 12,
      "passes": true,
      "notes": "Create AIShootingSystem : MonoBehaviour. Shooting range configurable via [SerializeField] float shootRange = 15f. Line-of-sight check: Physics.Linecast(ballPos, goalCenter, out hit, defenderLayerMask). Shot target: goalCenter + Random.Range(-goalHalfWidth*0.8, goalHalfWidth*0.8) on X axis. Shot force: ForceMode.Impulse with magnitude ~15-20. Integrate with AIController FSM: add Shooting state. Priority: shoot > pass when in range with clear line.",
      "dependsOn": ["US-010", "US-005"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-012'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-013",
      "title": "Goalkeeper AI with positioning and diving",
      "description": "As a player, I want a goalkeeper AI that positions itself between the ball and goal and dives toward shots so that goals require skillful play.",
      "acceptanceCriteria": [
        "Goalkeeper AI stays within the penalty/goal area bounds at all times",
        "Goalkeeper positions laterally between the ball's X position and the goal center X position",
        "Goalkeeper detects incoming shots by checking ball velocity direction toward the goal",
        "Goalkeeper performs a dive (rapid lateral movement) toward the ball when a shot is detected",
        "Goalkeeper blocks more than 30% of direct shots in a simulation of 20 shots from various angles",
        "GoalkeeperAI component exposes current state (Positioning, Diving, Recovering) for test verification",
        "Goalkeeper returns to center position after a dive within 2 seconds",
        "Goalkeeper does not leave the goal area to chase the ball upfield",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 13,
      "passes": true,
      "notes": "Create GoalkeeperAI : MonoBehaviour extending or parallel to AIController. States: Positioning, Diving, Recovering. Positioning: Mathf.Lerp between goal center and ball X, clamped to goal area width. Shot detection: Vector3.Dot(ballVelocity.normalized, directionToGoal) > 0.7 and ball speed > threshold. Dive: Rigidbody.MovePosition toward predicted ball intercept point. Use Time.fixedDeltaTime * diveSpeed for smooth dive. Recovery: lerp back to center over 2s.",
      "dependsOn": ["US-010", "US-005"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-013'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-014",
      "title": "Match state machine with full flow and pause support",
      "description": "As a developer, I want a comprehensive match state machine managing all match phases so that the game flow is predictable and testable.",
      "acceptanceCriteria": [
        "MatchStateMachine class implements states: PreKickoff, FirstHalf, HalfTime, SecondHalf, FullTime, GoalCelebration, Paused",
        "Valid transitions are enforced: PreKickoff->FirstHalf, FirstHalf->HalfTime, FirstHalf->GoalCelebration, HalfTime->SecondHalf, SecondHalf->FullTime, SecondHalf->GoalCelebration, GoalCelebration->PreKickoff, any->Paused, Paused->previous state",
        "Attempting an invalid transition throws an InvalidOperationException",
        "Pausing preserves the previous state and resuming restores it correctly",
        "MatchStateMachine fires an event on every state transition with old and new state",
        "All state transitions are verifiable in EditMode tests without scene loading",
        "MatchStateMachine exposes CurrentState and PreviousState read-only properties",
        "GoalCelebration state transitions back to PreKickoff (for kickoff reset)",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 14,
      "passes": true,
      "notes": "Create MatchStateMachine as a plain C# class. Use a Dictionary<MatchState, HashSet<MatchState>> for valid transitions. Store _previousState for pause/resume. Event: event Action<MatchState, MatchState> OnStateChanged. Transition method: void TransitionTo(MatchState newState) validates and fires event. Paused is special: store state before pause, restore on resume. A MatchStateMachineBehaviour MonoBehaviour wraps this and integrates with MatchTimer and GoalDetector events.",
      "dependsOn": ["US-007", "US-015"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-014'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-015",
      "title": "Kickoff sequence with ball placement and player reset",
      "description": "As a player, I want a proper kickoff sequence where the ball is placed at center and players move to formation positions so that each half and post-goal restart feels structured.",
      "acceptanceCriteria": [
        "Ball is placed at the exact center of the pitch during kickoff setup",
        "All 10 players move to their formation positions during kickoff setup",
        "A delay of approximately 1 second occurs between players reaching positions and play beginning",
        "After a goal, the same kickoff sequence resets the match state",
        "The team that did not score kicks off (alternating possession)",
        "KickoffSequence exposes a state (SettingUp, WaitingForKick, Complete) for test verification",
        "Ball is kinematic (Rigidbody.isKinematic = true) during setup and reverts to dynamic when play begins",
        "Players cannot move freely during the kickoff setup delay",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 15,
      "passes": true,
      "notes": "Create KickoffSequence : MonoBehaviour using a coroutine. Steps: 1) Set ball kinematic at center, 2) Move all players to FormationManager.GetWorldPositions(), 3) yield return new WaitForSeconds(1f), 4) Set ball non-kinematic, 5) Enable player input. Track which team kicks off with a bool that toggles on each goal. Use MatchStateMachine.TransitionTo(FirstHalf) at end. PlayerController.enabled = false during setup to block input.",
      "dependsOn": ["US-003", "US-007"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-015'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-016",
      "title": "Player switching to nearest teammate",
      "description": "As a player, I want to switch control to the teammate nearest to the ball so that I can always influence play effectively.",
      "acceptanceCriteria": [
        "A configured input button (e.g., 'Q' key or shoulder button) triggers player switching",
        "On switch, control transfers to the teammate nearest to the ball's current position",
        "A visual indicator (highlight, arrow, or ring) appears on the currently controlled player",
        "Only one player on the team is human-controlled at any time",
        "The previously controlled player reverts to AI control after switching",
        "Switching is instantaneous (completes within the same frame)",
        "PlayerSwitcher component exposes the currently active player reference for test verification",
        "Switching works correctly when multiple teammates are equidistant (deterministic tie-breaking)",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 16,
      "passes": true,
      "notes": "Create PlayerSwitcher : MonoBehaviour. On input, iterate team players, find min distance to ball (Vector3.Distance), swap PlayerController.enabled and AIController.enabled. Visual indicator: child GameObject with a SpriteRenderer or Projector, enabled only on active player. Use the Input System callback: playerSwitchAction.performed += ctx => SwitchPlayer(). Tie-breaking: use lowest player index. Store List<PlayerIdentity> teamPlayers reference.",
      "dependsOn": ["US-004", "US-009"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-016'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-017",
      "title": "Tackle mechanic with cooldown and dispossession",
      "description": "As a player, I want a tackle mechanic that lets me dispossess the ball carrier so that defense is engaging and skill-based.",
      "acceptanceCriteria": [
        "A configured input button (e.g., 'E' key or action button) triggers a tackle attempt",
        "Tackle causes the player to lunge forward toward the ball carrier's position",
        "If the tackler is within 1.5m radius of the ball carrier, dispossession occurs and the ball becomes loose",
        "The tackled player is briefly stunned (input disabled) for 0.5 seconds",
        "Tackle has a 1.0 second cooldown during which another tackle cannot be initiated",
        "After a successful tackle, the ball ownership changes to null (loose ball)",
        "TackleSystem component exposes IsCoolingDown and IsLunging properties for test verification",
        "A tackle attempt beyond 1.5m range does not cause dispossession",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 17,
      "passes": true,
      "notes": "Create TackleSystem : MonoBehaviour on each player. Lunge: Rigidbody.AddForce(directionToTarget * lungeForce, ForceMode.Impulse). Range check: Vector3.Distance(transform.position, ballCarrier.position) < tackleRadius. Dispossess: BallOwnership.SetOwner(null). Stun: set a flag, disable input for stunDuration via coroutine. Cooldown: track lastTackleTime, check Time.time - lastTackleTime > cooldownDuration. Integrate with BallOwnership (US-018).",
      "dependsOn": ["US-004", "US-018"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-017'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-018",
      "title": "Ball ownership tracking system",
      "description": "As a developer, I want a ball ownership system that tracks which player possesses the ball so that gameplay logic can respond to possession changes.",
      "acceptanceCriteria": [
        "BallOwnership component tracks the current owner as a PlayerIdentity reference (or null for loose ball)",
        "When possessed, the ball follows the owner at a fixed offset near their feet",
        "Ownership transfers correctly on pass (owner changes to null then to receiver)",
        "Ownership transfers correctly on tackle (owner changes to null)",
        "Ownership transfers correctly on shoot (owner changes to null, ball enters InFlight state)",
        "A loose ball can be claimed by the nearest player within a proximity threshold (e.g., 1m)",
        "BallOwnership fires an OnOwnerChanged event with previous and new owner references",
        "BallOwnership.CurrentOwner property returns the current possessing player or null",
        "Two players cannot simultaneously own the ball",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 18,
      "passes": true,
      "notes": "Create BallOwnership : MonoBehaviour on the Ball. Fields: PlayerIdentity _currentOwner, float claimRadius = 1f, Vector3 possessionOffset = new Vector3(0, 0.1f, 0.5f). In FixedUpdate: if owned, set ball position to owner.transform.position + owner.transform.forward * offset. Claim logic: if _currentOwner == null, check all players within claimRadius using Physics.OverlapSphere. Event: event Action<PlayerIdentity, PlayerIdentity> OnOwnerChanged. Use layers to filter player colliders only.",
      "dependsOn": ["US-003", "US-004"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-018'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-019",
      "title": "Player animation state machine with placeholder animations",
      "description": "As a player, I want player characters to animate based on their actions so that the game feels alive and responsive.",
      "acceptanceCriteria": [
        "An Animator Controller asset exists with states: Idle, Run, Sprint, Kick, Tackle, Celebrate",
        "A Blend Tree is used for movement states, blending between Idle, Run, and Sprint based on a 'Speed' float parameter",
        "Animator transitions to Kick state when a 'Kick' trigger parameter is set",
        "Animator transitions to Tackle state when a 'Tackle' trigger parameter is set",
        "Animator transitions to Celebrate state when a 'Celebrate' trigger parameter is set",
        "Correct animation state plays based on PlayerController/AIController current action",
        "Placeholder animations use simple transform manipulations (e.g., scaling, bobbing) until Mixamo integration",
        "PlayerAnimator component bridges PlayerController state to Animator parameters",
        "Each animation state can be verified by checking Animator.GetCurrentAnimatorStateInfo(0).IsName(stateName)",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 19,
      "passes": true,
      "notes": "Create PlayerAnimator : MonoBehaviour with [RequireComponent(typeof(Animator))]. Map PlayerController.CurrentSpeed to Animator.SetFloat('Speed', speed). Map actions to triggers: Animator.SetTrigger('Kick'), etc. Create AnimatorController in Editor or via AnimatorController.CreateAnimatorControllerAtPath(). Blend Tree thresholds: 0 = Idle, 0.5 = Run, 1.0 = Sprint. Placeholder AnimationClips: use AnimationCurve to bob Y position. Has Exit Time on action states to return to locomotion.",
      "dependsOn": ["US-004", "US-010"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-019'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-020",
      "title": "Ball kick animation synchronized with force application",
      "description": "As a player, I want the kick animation to sync with ball force application so that kicks feel responsive and connected.",
      "acceptanceCriteria": [
        "Kick animation triggers when the player executes a pass or shoot action",
        "Ball force is applied at the animation contact frame via an AnimationEvent callback",
        "Time from input press to ball movement is less than 100ms (responsive feel)",
        "Ball direction after kick matches the player's facing direction (transform.forward)",
        "Kick force magnitude is configurable and differs between pass and shoot",
        "AnimationEvent method is named OnKickContact and is callable in tests",
        "Ball does not move before the kick contact frame in the animation",
        "After kick completes, player returns to locomotion animation state",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 20,
      "passes": true,
      "notes": "Add AnimationEvent to kick AnimationClip at the contact frame (~0.15s into clip for responsiveness). Event calls PlayerKicker.OnKickContact(). PlayerKicker : MonoBehaviour stores pending kick data (direction, force, type). On contact: ball.GetComponent<Rigidbody>().AddForce(direction * force, ForceMode.Impulse). BallOwnership.Release() called before force. Pass force ~8, Shoot force ~15. For <100ms feel, place AnimationEvent early in the clip or skip to contact frame.",
      "dependsOn": ["US-019", "US-003"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-020'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-021",
      "title": "Goal celebration sequence with slow-motion and camera zoom",
      "description": "As a player, I want a cinematic goal celebration with slow-motion and camera zoom so that scoring feels rewarding and dramatic.",
      "acceptanceCriteria": [
        "On goal scored, Time.timeScale is set to 0.3 for approximately 2 real-time seconds",
        "Camera zooms to the scoring player during celebration using a dedicated Cinemachine virtual camera or priority boost",
        "Scoring player's Animator triggers the 'Celebrate' animation state",
        "After the celebration duration, Time.timeScale returns to 1.0",
        "Kickoff sequence begins after celebration completes",
        "CelebrationSequence component exposes IsPlaying property for test verification",
        "The celebration sequence handles Time.unscaledDeltaTime correctly for real-time duration tracking",
        "Multiple rapid goals do not stack celebration sequences (only one plays at a time)",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 21,
      "passes": true,
      "notes": "Create CelebrationSequence : MonoBehaviour using coroutine with WaitForSecondsRealtime(2f) (unscaled time). Steps: 1) Time.timeScale = 0.3f, 2) Boost celebration CinemachineCamera priority, 3) scorer.Animator.SetTrigger('Celebrate'), 4) yield WaitForSecondsRealtime(2f), 5) Time.timeScale = 1.0f, 6) Restore camera priorities, 7) Trigger KickoffSequence. Use a flag _isPlaying to prevent stacking. Subscribe to GoalDetector.OnGoalScored.",
      "dependsOn": ["US-005", "US-006", "US-019"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-021'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-022",
      "title": "Ball trail particle effect at high velocity",
      "description": "As a player, I want a visible trail on the ball when it moves fast so that powerful shots and passes are visually exciting.",
      "acceptanceCriteria": [
        "A ParticleSystem component is attached to or is a child of the Ball GameObject",
        "Particles emit only when ball velocity magnitude exceeds 10 m/s",
        "Trail color intensity (alpha or brightness) scales proportionally with ball speed",
        "No particles are emitted when the ball is stationary or moving slowly (below 10 m/s)",
        "Active particle count never exceeds 50 at any time, verified via ParticleSystem.particleCount",
        "BallTrailEffect component enables/disables emission based on velocity threshold",
        "Particle lifetime and emission rate are configurable via serialized fields",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 22,
      "passes": true,
      "notes": "Create BallTrailEffect : MonoBehaviour on Ball. In Update: float speed = _rb.linearVelocity.magnitude; var emission = _ps.emission; emission.enabled = speed > velocityThreshold. Scale startColor alpha: Color.Lerp(minColor, maxColor, (speed - threshold) / maxSpeed). Set emission.rateOverTime = Mathf.Lerp(5, 30, speedRatio). ParticleSystem settings: startLifetime 0.3, startSize 0.1, maxParticles 50, renderMode Billboard, material additive.",
      "dependsOn": ["US-003"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-022'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-023",
      "title": "Sound effects for whistle, kick, crowd, and goal",
      "description": "As a player, I want sound effects for key match events so that the game feels immersive and alive.",
      "acceptanceCriteria": [
        "An AudioSource plays a whistle sound on match start, halftime, and fulltime events",
        "An AudioSource plays a kick sound when the ball is struck by a player",
        "A persistent crowd ambient AudioSource loops throughout the match",
        "An AudioSource plays a goal celebration sound when GoalScored event fires",
        "AudioSource.isPlaying returns true for the correct source immediately after each event trigger in PlayMode tests",
        "All AudioClip references are assigned (not null) on the relevant AudioSource components",
        "SoundManager singleton component centralizes audio playback with public Play methods",
        "Sound effects use placeholder AudioClips (short generated tones) until real assets are integrated",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 23,
      "passes": true,
      "notes": "Create SoundManager : MonoBehaviour singleton. Fields: AudioClip whistleClip, kickClip, crowdAmbientClip, goalCheerClip. Multiple AudioSource components for simultaneous playback: one for SFX (PlayOneShot), one for ambient (loop=true). Subscribe to events: MatchStateMachine.OnStateChanged for whistle timing, PlayerKicker.OnKickContact for kick sound, GoalDetector.OnGoalScored for cheer. Generate placeholder clips via AudioClip.Create() with simple sine wave data.",
      "dependsOn": ["US-005", "US-007"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-023'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-024",
      "title": "Camera shake on goal via Cinemachine Impulse",
      "description": "As a player, I want the camera to shake when a goal is scored so that the moment feels impactful.",
      "acceptanceCriteria": [
        "A CinemachineImpulseSource component exists in the Match scene",
        "The impulse source fires on the GoalScored event",
        "Shake intensity is configurable via a serialized field",
        "Shake duration is between 0.5 and 1.0 seconds",
        "Camera position returns to stable (no residual shake) after the shake duration ends",
        "CinemachineImpulseListener is configured on the active virtual camera",
        "GoalCameraShake component exposes the impulse source reference for test verification",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 24,
      "passes": true,
      "notes": "Create GoalCameraShake : MonoBehaviour. [SerializeField] CinemachineImpulseSource impulseSource. [SerializeField] float shakeIntensity = 1f. Subscribe to GoalDetector.OnGoalScored. On goal: impulseSource.GenerateImpulse(shakeIntensity). Configure ImpulseSource: Raw Signal = 6D Shake, Time = 0.7, Decay = 1. Add CinemachineImpulseListener to the CinemachineCamera. Test: after impulse, check camera position displacement, then verify it settles after duration.",
      "dependsOn": ["US-006", "US-005"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-024'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-025",
      "title": "Dynamic crowd reaction audio",
      "description": "As a player, I want the crowd noise to react dynamically to match events so that the atmosphere feels alive.",
      "acceptanceCriteria": [
        "Crowd ambient volume scales based on ball proximity to either goal (louder when near goal areas)",
        "A crowd roar AudioClip plays on goal scored events",
        "A crowd groan AudioClip plays on near-miss events (ball passes close to goal but no goal)",
        "Base ambient crowd volume is set to approximately 30% of max volume",
        "Dynamic volume mixing uses an AudioMixer with a 'CrowdVolume' exposed parameter",
        "CrowdReactionSystem component exposes current crowd intensity (0-1) for test verification",
        "Volume transitions are smooth (lerped) rather than instant",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 25,
      "passes": true,
      "notes": "Create CrowdReactionSystem : MonoBehaviour. Use AudioMixer with 'Crowd' group and exposed 'CrowdVolume' parameter. In Update: calculate ball distance to nearest goal, map to 0-1 intensity (closer = higher). AudioMixer.SetFloat('CrowdVolume', Mathf.Lerp(-20f, 0f, intensity)) in dB. Near-miss detection: ball velocity toward goal + ball passes within 2m of goal post without scoring. Lerp intensity: Mathf.MoveTowards(current, target, Time.deltaTime * lerpSpeed).",
      "dependsOn": ["US-023"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-025'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-026",
      "title": "Player run dust particle effects",
      "description": "As a player, I want dust particles at player feet when running so that movement feels grounded and physical.",
      "acceptanceCriteria": [
        "A small dust ParticleSystem is positioned at each player's feet",
        "Particles emit only when the player's speed exceeds a walk threshold (e.g., > 2 m/s)",
        "Particles are aligned to the ground plane (emitting horizontally, not upward)",
        "Maximum particle count per player is 20 or fewer at any time",
        "No particles emit when the player is stationary or walking slowly",
        "RunDustEffect component enables/disables emission based on speed threshold",
        "Particle emission rate scales with player speed",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 26,
      "passes": true,
      "notes": "Create RunDustEffect : MonoBehaviour on each player as child GameObject at feet (localPosition Y ~0.05). ParticleSystem settings: shape = Hemisphere rotated down, startLifetime 0.4, startSize 0.15, startSpeed 0.5, maxParticles 20, startColor brownish-tan, simulation space World. In Update: var emission = _ps.emission; float speed = _rb.linearVelocity.magnitude; emission.enabled = speed > walkThreshold; emission.rateOverTime = Mathf.Lerp(2, 15, (speed - walkThreshold) / maxSpeed).",
      "dependsOn": ["US-004"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-026'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-027",
      "title": "Replay system for last 5 seconds on goal",
      "description": "As a player, I want to see a replay of the last 5 seconds when a goal is scored so that I can relive exciting moments.",
      "acceptanceCriteria": [
        "A ring buffer continuously records transform positions and rotations of all game objects (ball + players) at 30 fps",
        "On goal trigger, replay playback starts from 5 seconds before the goal",
        "Replay uses a different camera angle than the live gameplay camera",
        "Replay plays at 0.5x speed",
        "Normal gameplay resumes automatically after the replay finishes",
        "ReplaySystem component exposes IsRecording and IsPlaying properties for test verification",
        "Ring buffer capacity is sufficient for at least 5 seconds at 30 fps (150 frames)",
        "Replay does not allocate garbage during recording (pre-allocated buffer)",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 27,
      "passes": true,
      "notes": "Create ReplaySystem : MonoBehaviour. Struct ReplayFrame { Vector3[] positions; Quaternion[] rotations; float timestamp; }. Ring buffer: ReplayFrame[] buffer = new ReplayFrame[150]; int writeIndex. Record in FixedUpdate at 30fps interval. On goal: pause live game, switch to replay CinemachineCamera, iterate buffer from 5s ago at 0.5x speed using Time.unscaledDeltaTime. Apply recorded transforms to objects. Pre-allocate all arrays to avoid GC. Use a dedicated 'Replay' CinemachineCamera with different angle.",
      "dependsOn": ["US-005", "US-006"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-027'"],
      "estimatedScope": "large"
    },
    {
      "id": "US-028",
      "title": "Main menu scene with navigation buttons",
      "description": "As a player, I want a main menu with Play, Settings, and Credits buttons so that I can navigate the game easily.",
      "acceptanceCriteria": [
        "A scene named 'MainMenu' exists in the Build Settings scene list",
        "The scene contains a Canvas with three interactable Button components: Play, Settings, Credits",
        "The Play button triggers loading of the 'TeamSelect' scene",
        "The Settings button triggers loading of the 'Settings' scene or opens a settings panel",
        "The Credits button triggers loading of a 'Credits' scene or opens a credits panel",
        "A TextMeshPro text element displays the title 'OpenFifa'",
        "All buttons have non-zero RectTransform size and are interactable (Button.interactable == true)",
        "UI scales correctly using CanvasScaler with Screen Space - Overlay and 'Scale With Screen Size'",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 28,
      "passes": true,
      "notes": "Create MainMenuController : MonoBehaviour with public methods: OnPlayClicked(), OnSettingsClicked(), OnCreditsClicked(). Use SceneManager.LoadScene('TeamSelect') etc. Button.onClick.AddListener via Inspector or code. CanvasScaler: referenceResolution 1920x1080, matchWidthOrHeight 0.5. Title TMP at top-center, buttons stacked vertically at center. Test: find buttons via GameObject.Find or GetComponentInChildren<Button>, verify interactable, invoke onClick.",
      "dependsOn": ["US-001"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-028'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-029",
      "title": "Team selection screen with team roster",
      "description": "As a player, I want to select my team from a list so that I can choose my preferred team identity and colors.",
      "acceptanceCriteria": [
        "A scene named 'TeamSelect' exists in the Build Settings scene list",
        "The scene displays at least 4 teams with distinct names and colors",
        "Each team is defined by a TeamData ScriptableObject (name, primary color, secondary color)",
        "Player can select their team by tapping/clicking a team button, which highlights the selection",
        "AI is automatically assigned a different team (not the player's selection)",
        "A confirm button loads the 'Match' scene when a team is selected",
        "Selected team data is accessible after scene transition via a static reference or ScriptableObject",
        "The confirm button is not interactable until a team is selected",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 29,
      "passes": true,
      "notes": "Create TeamData : ScriptableObject with fields: string teamName, Color primaryColor, Color secondaryColor. Create TeamSelectController : MonoBehaviour. Display teams in a horizontal or grid layout. Selection: set _selectedTeam and highlight via outline or scale. AI team: pick random from remaining. Pass data: use a MatchSettings ScriptableObject (playerTeam, aiTeam) that persists across scenes (asset reference, not destroyed). Confirm: Button.interactable = _selectedTeam != null, then SceneManager.LoadScene('Match').",
      "dependsOn": ["US-028", "US-009"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-029'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-030",
      "title": "Full match HUD with minimap and match state",
      "description": "As a player, I want a comprehensive match HUD with score, timer, minimap, and match state indicator so that I have full situational awareness.",
      "acceptanceCriteria": [
        "Score display shows team names and current score in the format 'TeamA X - Y TeamB'",
        "Timer display shows remaining time as 'MM:SS' and updates every frame",
        "A minimap RawImage or RenderTexture shows a top-down pitch overview with colored dots for players",
        "Current match state text is displayed (e.g., 'FIRST HALF', 'HALF TIME', 'SECOND HALF')",
        "All HUD elements respect platform safe area insets (positioned within SafeArea bounds on iPad, within window bounds on macOS)",
        "Minimap dots correctly represent player positions relative to the pitch",
        "HUD updates reflect score changes within the same frame",
        "Match state text updates on MatchStateMachine state transitions",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 30,
      "passes": true,
      "notes": "Extend HUDController from US-008. Minimap: use a second Camera (orthographic, top-down, culling mask 'Minimap') rendering to a RenderTexture displayed on a RawImage. Or use UI Image dots positioned by mapping world coordinates to minimap rect. Safe area: use Screen.safeArea to offset RectTransforms. Match state text: subscribe to MatchStateMachine.OnStateChanged, map enum to display strings. Minimap player dots: small Image components repositioned each frame.",
      "dependsOn": ["US-008", "US-014"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-030'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-031",
      "title": "Pause menu with resume, restart, and quit",
      "description": "As a player, I want a pause menu that stops gameplay and gives options to resume, restart, or quit so that I can take a break or exit gracefully.",
      "acceptanceCriteria": [
        "A pause button or input (e.g., Escape key or on-screen button) sets Time.timeScale to 0 and shows the pause overlay",
        "The pause overlay displays Resume, Restart, and Quit buttons",
        "Resume button restores Time.timeScale to its pre-pause value and hides the overlay",
        "Restart button reloads the current Match scene from the beginning",
        "Quit button loads the MainMenu scene",
        "Game physics and AI are frozen while paused (Time.timeScale == 0)",
        "PauseMenu component exposes an IsPaused property for test verification",
        "Pause and resume cycle preserves the match state correctly",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 31,
      "passes": true,
      "notes": "Create PauseMenu : MonoBehaviour. On pause input: Time.timeScale = 0, enable overlay Canvas/Panel (SetActive(true)). Store _previousTimeScale before setting to 0. Resume: Time.timeScale = _previousTimeScale, disable overlay. Restart: Time.timeScale = 1, SceneManager.LoadScene(SceneManager.GetActiveScene().name). Quit: Time.timeScale = 1, SceneManager.LoadScene('MainMenu'). Integrate with MatchStateMachine.TransitionTo(Paused) and resume to previous state. Use EventSystem to handle button clicks while paused (UI ignores timeScale).",
      "dependsOn": ["US-014", "US-028"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-031'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-032",
      "title": "Post-match results screen",
      "description": "As a player, I want a results screen after the match showing the final score and options to replay or return to menu so that I know the outcome and can continue playing.",
      "acceptanceCriteria": [
        "A scene named 'Results' exists in the Build Settings scene list or a results panel activates in the Match scene",
        "Final score is displayed in format 'TeamA X - Y TeamB'",
        "Match duration is displayed (total time from kickoff to full time)",
        "Man of the match is determined by the player with the most goals and displayed by name",
        "A 'Play Again' button loads the Match scene (or TeamSelect scene) to start a new match",
        "A 'Main Menu' button loads the MainMenu scene",
        "Match data (score, duration, goal scorers) is passed from the Match scene to the Results display",
        "Both buttons are interactable and functional",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 32,
      "passes": true,
      "notes": "Create MatchResultsData : ScriptableObject to persist across scenes (playerTeamScore, aiTeamScore, matchDuration, List<GoalRecord> goals). GoalRecord struct: PlayerIdentity scorer, float matchTime, TeamIdentifier team. ResultsScreenController reads MatchResultsData. Man of the match: LINQ GroupBy scorer, OrderByDescending count, First(). Play Again: SceneManager.LoadScene('TeamSelect'). Main Menu: SceneManager.LoadScene('MainMenu'). Populate data in MatchManager before scene transition.",
      "dependsOn": ["US-014", "US-028"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-032'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-033",
      "title": "Settings screen with volume and difficulty controls",
      "description": "As a player, I want a settings screen where I can adjust volume and difficulty so that I can customize the game to my preferences.",
      "acceptanceCriteria": [
        "A settings UI exists (scene or panel) with sliders for SFX volume and Music volume (range 0-100)",
        "A difficulty dropdown or toggle offers Easy, Medium, and Hard options",
        "Settings persist between app sessions using PlayerPrefs",
        "Changing SFX volume immediately affects SFX AudioMixer group volume",
        "Changing Music volume immediately affects Music AudioMixer group volume",
        "PlayerPrefs keys are documented and consistent (e.g., 'SFXVolume', 'MusicVolume', 'Difficulty')",
        "On settings load, sliders and dropdown reflect the persisted values",
        "Settings can be read from PlayerPrefs in an EditMode test",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 33,
      "passes": true,
      "notes": "Create SettingsManager : MonoBehaviour. Sliders: Slider.onValueChanged.AddListener(OnSFXVolumeChanged). Map 0-100 to AudioMixer dB: Mathf.Log10(value / 100f) * 20f (handle 0 as -80dB). PlayerPrefs.SetFloat('SFXVolume', value), PlayerPrefs.SetFloat('MusicVolume', value), PlayerPrefs.SetInt('Difficulty', index). Load in Start: slider.value = PlayerPrefs.GetFloat('SFXVolume', 75f). Difficulty enum { Easy, Medium, Hard } mapped to AI reaction time multipliers.",
      "dependsOn": ["US-028"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-033'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-034",
      "title": "Scene transition system with fade-to-black",
      "description": "As a player, I want smooth fade-to-black transitions between scenes so that scene changes feel polished rather than jarring.",
      "acceptanceCriteria": [
        "All scene transitions use a fade-to-black effect (screen goes dark then reveals new scene)",
        "Fade duration is configurable between 0.3 and 1.0 seconds",
        "No flash of unloaded or partially loaded content is visible during transitions",
        "Fade works correctly with Unity async scene loading (SceneManager.LoadSceneAsync)",
        "SceneTransition singleton provides a public LoadScene(string sceneName) method",
        "Fade uses a full-screen UI Image with CanvasGroup.alpha animated from 0 to 1 and back",
        "SceneTransition.IsTransitioning property returns true during an active transition",
        "Transition cannot be interrupted by another transition request (queued or blocked)",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 34,
      "passes": true,
      "notes": "Create SceneTransition : MonoBehaviour singleton (DontDestroyOnLoad). Child Canvas (sortingOrder 999) with black Image and CanvasGroup. Coroutine: fade alpha 0->1 over duration, yield LoadSceneAsync, wait until done, fade alpha 1->0. Use DOTween or manual Mathf.MoveTowards in Update. Prevent double-transition with _isTransitioning flag. Replace all SceneManager.LoadScene calls with SceneTransition.Instance.LoadScene(). Test: verify IsTransitioning flag and alpha values.",
      "dependsOn": ["US-028"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-034'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-035",
      "title": "End-to-end user journey automated test",
      "description": "As a developer, I want an automated end-to-end test that exercises the full user journey so that regressions in the game flow are caught early.",
      "acceptanceCriteria": [
        "A PlayMode test exists that navigates: MainMenu -> Play -> TeamSelect -> Confirm -> Match -> FullTime -> Results -> MainMenu",
        "The test runs the match at 100x time scale to complete quickly",
        "The test completes within 5 minutes of real wall-clock time",
        "No errors or exceptions are logged during the entire journey",
        "No null reference exceptions occur during scene transitions",
        "The test verifies each scene loads successfully by checking for expected GameObjects",
        "The test verifies the Results screen displays a valid final score",
        "The test returns to MainMenu successfully at the end",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 35,
      "passes": true,
      "notes": "Create E2EUserJourneyTest : MonoBehaviour in PlayMode test assembly with [UnityTest][Timeout(300000)]. Use SceneManager.LoadScene in sequence. Simulate button clicks: button.onClick.Invoke(). Set Time.timeScale = 100 during match. Wait for MatchStateMachine to reach FullTime using WaitUntil(() => matchState == FullTime). Verify GameObjects: Assert.IsNotNull(GameObject.Find('ExpectedObject')). Check Debug.logHandler for errors. Reset timeScale at end. Use [Category('US-035')] and [Category('E2E')].",
      "dependsOn": ["US-028", "US-029", "US-030", "US-031", "US-032", "US-033", "US-034"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-035'"],
      "estimatedScope": "large"
    },
    {
      "id": "US-036",
      "title": "Keyboard/mouse controls (macOS) + virtual joystick (iPad)",
      "description": "As a player, I want keyboard/mouse/trackpad controls on macOS and a virtual joystick on iPad so that I can control my player natively on each platform.",
      "acceptanceCriteria": [
        "On macOS: WASD/Arrow keys provide normalized Vector2 movement input to PlayerController",
        "On macOS: Mouse/trackpad position is tracked for optional camera look direction",
        "On iPad: A virtual joystick appears in the lower-left quadrant of the screen on touch input",
        "On iPad: The joystick is dynamic (appears at the touch point rather than a fixed position)",
        "A dead zone of 10% prevents accidental drift on both input methods",
        "The input provides a normalized Vector2 output to the PlayerController for movement",
        "An IInputProvider interface abstracts keyboard (macOS) and touch (iPad) input sources",
        "Input source is auto-detected based on platform at runtime",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 36,
      "passes": true,
      "notes": "Create IInputProvider interface with GetMovement():Vector2, GetActions(). KeyboardInputProvider for macOS (WASD/Arrows via Unity Input System). TouchInputProvider with VirtualJoystick for iPad. Auto-detect platform: #if UNITY_STANDALONE_OSX use keyboard, #if UNITY_IOS use touch. VirtualJoystick: IPointerDownHandler, IDragHandler, IPointerUpHandler. Outer ring Image anchored to touch start position. Inner thumb clamped within outer radius. Output = (thumbPos - centerPos) / radius, with dead zone.",
      "dependsOn": ["US-004"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-036'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-037",
      "title": "Keyboard shortcuts (macOS) + touch buttons (iPad)",
      "description": "As a player, I want keyboard shortcuts on macOS and on-screen action buttons on iPad so that I can pass, shoot, tackle, and sprint natively on each platform.",
      "acceptanceCriteria": [
        "On macOS: Z/Left Click triggers Pass, X/Right Click triggers Shoot, C triggers Tackle, Left Shift triggers Sprint",
        "On macOS: Keyboard shortcuts provide immediate response with no input lag",
        "On iPad: Pass, Shoot, Tackle, and Sprint buttons are positioned in the lower-right quadrant of the screen",
        "On iPad: Sprint button responds to hold (continuous press) rather than tap",
        "On iPad: Pass, Shoot, and Tackle buttons respond to single tap",
        "Visual feedback (scale or color change) occurs on button press (iPad) and key press (macOS)",
        "Each action triggers the corresponding action on the PlayerController via IInputProvider",
        "ActionButtons component exposes which buttons are currently pressed for test verification",
        "On iPad: Buttons are sized appropriately for touch (minimum 44x44 point tap target)",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 37,
      "passes": true,
      "notes": "macOS: Use Unity Input System keyboard bindings: Z=Pass, X=Shoot, C=Tackle, LeftShift=Sprint, Tab=Switch. Mouse: LeftClick=Pass, RightClick=Shoot. iPad: Create ActionButtons : MonoBehaviour with child Button GameObjects. Sprint: IPointerDownHandler (set sprinting=true) and IPointerUpHandler (set sprinting=false). Visual feedback: DOTween scale punch or simple localScale change on press. Layout: 2x2 grid or diamond arrangement. Minimum RectTransform size 80x80. Wire to PlayerController via IInputProvider interface.",
      "dependsOn": ["US-036", "US-017"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-037'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-038",
      "title": "Haptic feedback (iPad) + screen shake/audio feedback (macOS)",
      "description": "As a player, I want haptic feedback on iPad and screen shake/audio feedback on macOS for key game events so that the game feels tactile and immersive on both platforms.",
      "acceptanceCriteria": [
        "On iPad: A heavy haptic (UIImpactFeedbackGenerator.Heavy) triggers on goal scored",
        "On iPad: A medium haptic (UIImpactFeedbackGenerator.Medium) triggers on successful tackle",
        "On iPad: A light haptic (UIImpactFeedbackGenerator.Light) triggers on whistle events",
        "On iPad: Haptics respect the iPadOS system haptic setting (no haptics if disabled by user)",
        "On macOS: Screen shake effect triggers on goal scored (camera displacement + recovery)",
        "On macOS: Audio impact SFX triggers on successful tackle and whistle events",
        "No crash occurs on devices/platforms that do not support haptics (graceful fallback)",
        "GameFeedback component provides a public Trigger(FeedbackIntensity intensity) method with platform-aware dispatch",
        "Feedback calls are platform-aware: haptic on iPad (#if UNITY_IOS), screen shake + audio on macOS (#if UNITY_STANDALONE_OSX)",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 38,
      "passes": true,
      "notes": "Create GameFeedback : MonoBehaviour singleton with platform dispatch. iPad: Use native plugin (.mm) with UIImpactFeedbackGenerator for haptics. macOS: Use Cinemachine impulse source for screen shake + AudioSource.PlayOneShot for impact SFX. Enum FeedbackIntensity { Light, Medium, Heavy }. #if UNITY_IOS for haptics, #if UNITY_STANDALONE_OSX for screen shake. Subscribe to GoalDetector.OnGoalScored, TackleSystem.OnTackle, MatchStateMachine.OnStateChanged.",
      "dependsOn": ["US-005", "US-017"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-038'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-039",
      "title": "Draw call optimization with batching and instancing",
      "description": "As a developer, I want draw calls optimized under 100 batches so that the game runs smoothly on macOS and iPad.",
      "acceptanceCriteria": [
        "Total batches during gameplay is less than 100, verified via Unity profiler stats",
        "GPU instancing is enabled on all materials used by players, ball, and pitch objects",
        "Static batching is enabled on pitch and stadium environment objects (marked as Batching Static)",
        "Dynamic batching is enabled in Player Settings for player and ball objects",
        "A PlayMode test reads UnityEngine.Rendering.OnDemandRendering or frame stats to verify batch count",
        "No materials have GPU instancing disabled that could be enabled",
        "Shared materials are used where possible (players on same team share one material instance)",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 39,
      "passes": true,
      "notes": "Enable GPU Instancing: material.enableInstancing = true on all materials. Mark static objects: GameObjectUtility.SetStaticEditorFlags(go, StaticEditorFlags.BatchingStatic). Player Settings: enable Dynamic Batching and GPU Instancing. Verify in test: use ProfilerRecorder('Total Batches Count') from Unity.Profiling. Team materials: create 2 material instances (TeamA, TeamB), assign to all players on that team via MaterialPropertyBlock for per-instance color without breaking batching. Combine meshes where possible.",
      "dependsOn": ["US-019"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-039'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-040",
      "title": "GC-free gameplay loop with object pooling",
      "description": "As a developer, I want zero garbage collection allocations during gameplay so that there are no frame hitches on macOS and iPad.",
      "acceptanceCriteria": [
        "Zero GC.Alloc bytes measured during a 2-second gameplay window using ProfilerRecorder",
        "No string concatenation occurs in any Update, FixedUpdate, or LateUpdate method",
        "Object pooling is implemented for particle systems and any frequently instantiated objects",
        "StringBuilder or cached strings are used for any HUD text updates",
        "ObjectPool<T> generic class exists with Get() and Return() methods",
        "Pool pre-warms a configurable number of instances on scene load",
        "Verified via ProfilerRecorder('GC.Alloc') in a PlayMode test measuring allocation count",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 40,
      "passes": true,
      "notes": "Create ObjectPool<T> : where T : Component. Pool uses Stack<T> internally. Get(): pop from stack or Instantiate. Return(T obj): deactivate and push. Pre-warm: for loop Instantiate in Awake. HUD: use StringBuilder with .Clear().Append() instead of string interpolation. Cache ToString() results for timer. Use ProfilerRecorder from Unity.Profiling: var recorder = ProfilerRecorder.StartNew(ProfilerCategory.Memory, 'GC.Alloc'); after 2s check recorder.CurrentValue == 0. Avoid foreach on non-struct enumerables, use for loops.",
      "dependsOn": ["US-018"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-040'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-041",
      "title": "Multi-resolution UI (macOS windows + iPad sizes)",
      "description": "As a player, I want the UI to display correctly across macOS window sizes and iPad resolutions so that the game is playable on any supported device.",
      "acceptanceCriteria": [
        "All HUD elements are visible and not clipped at macOS minimum window size (1280x720)",
        "All HUD elements are visible and not clipped at macOS typical resolution (1920x1080)",
        "All HUD elements are visible and not clipped at macOS Retina resolution (2560x1600)",
        "All HUD elements are visible and not clipped at iPad Pro 11 resolution (1668x2388)",
        "All HUD elements are visible and not clipped at iPad Pro 12.9 resolution (2048x2732)",
        "All HUD elements are visible and not clipped at iPad Air resolution (1640x2360)",
        "Verification is done by checking RectTransform world corners are within screen bounds at each resolution",
        "CanvasScaler is configured to handle all target aspect ratios (16:10 to 4:3)",
        "On iPad: Touch targets remain at minimum 44pt equivalent size across all resolutions",
        "macOS window is resizable with a minimum size constraint of 1280x720",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 41,
      "passes": true,
      "notes": "PlayMode test approach: use Screen.SetResolution(w, h, false) or configure GameView via reflection to test each resolution. For each resolution: iterate all RectTransforms in HUD, call GetWorldCorners(corners), verify all corners are within (0,0)-(Screen.width,Screen.height). CanvasScaler: matchWidthOrHeight = 0.5 to balance landscape. Anchor UI elements to edges/corners. Use LayoutGroups for flexible arrangement. Test with [TestCase(1280, 720)] parameterized tests for macOS and [TestCase(1668, 2388)] for iPad. macOS: set minimum window size via PlayerSettings or native plugin.",
      "dependsOn": ["US-030"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-041'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-042",
      "title": "macOS + iPad build hardening and verification",
      "description": "As a developer, I want both the macOS and iPad builds to be production-ready with correct frameworks and size constraints so that the apps can be distributed.",
      "acceptanceCriteria": [
        "macOS .app bundle generates successfully from Unity without errors",
        "macOS .app bundle contains required frameworks: Metal, AppKit, AVFoundation",
        "macOS .app bundle size is less than 200MB",
        "macOS .app launches without immediate crash (smoke test)",
        "iPad Xcode project generates successfully from Unity without errors",
        "iPad build compiles for iPad Simulator target (arm64-apple-ios-simulator) without errors",
        "iPad app bundle size is less than 200MB after build",
        "iPad build links Metal, UIKit, and AVFoundation frameworks",
        "A verify-build.sh script exists that checks all the above criteria for both platforms and exits with 0 on success",
        "Player Settings are configured: minimum macOS version 14.0 (Sonoma), minimum iPadOS version 17.0, target architecture ARM64",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 42,
      "passes": true,
      "notes": "Set PlayerSettings: macOS minimum version 14.0, iPadOS minimum version 17.0, architecture ARM64, scripting backend IL2CPP, API Compatibility .NET Standard 2.1. Create verify-build.sh: macOS section checks .app exists, bundle size, frameworks (Metal, AppKit, AVFoundation). iPad section checks Xcode project exists, runs xcodebuild for iPad Simulator, checks bundle size, frameworks (Metal, UIKit, AVFoundation). Use BuildPipeline.BuildPlayer with both StandaloneOSX and iOS targets. Strip engine code to reduce size.",
      "dependsOn": ["US-001"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-042'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-043",
      "title": "Performance budget test suite",
      "description": "As a developer, I want an automated performance test suite so that frame rate, draw calls, and GC allocations are continuously monitored.",
      "acceptanceCriteria": [
        "Average FPS is greater than 28 during a 5-second gameplay measurement window",
        "No single frame takes longer than 100ms (worst frame < 100ms)",
        "Less than 5% of frames exceed 33ms (30fps threshold)",
        "Draw batch count is less than 100 during gameplay",
        "Zero GC allocations occur during the 5-second measurement window",
        "All performance tests are in a single test class with [Category('Performance')]",
        "Tests use Unity ProfilerRecorder API for measurements",
        "Performance thresholds are configurable via constants for easy adjustment",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 43,
      "passes": true,
      "notes": "Create PerformanceBudgetTests PlayMode test class. Use ProfilerRecorder: new ProfilerRecorder(ProfilerCategory.Render, 'Total Batches Count'), new ProfilerRecorder(ProfilerCategory.Internal, 'CPU Main Thread Frame Time'). Run 5s of gameplay (yield for 150 frames at 30fps). Collect frame times in a List<double>. Assert: avg < 1/28s, max < 100ms, percentile(95) < 33ms. GC: ProfilerRecorder(ProfilerCategory.Memory, 'GC.Alloc'). Constants: const float MIN_AVG_FPS = 28f, const float MAX_FRAME_MS = 100f, etc.",
      "dependsOn": ["US-039", "US-040"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-043'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-044",
      "title": "Import Quaternius low-poly characters with team colors",
      "description": "As a player, I want low-poly humanoid character models with team-colored uniforms so that the game looks visually appealing and teams are distinguishable.",
      "acceptanceCriteria": [
        "Low-poly humanoid 3D models replace the placeholder capsule meshes for all players",
        "Team A players use a distinct material color (e.g., blue primary)",
        "Team B players use a distinct material color (e.g., red primary)",
        "Models are configured with Unity Humanoid avatar rig for animation compatibility",
        "Existing animation states (Idle, Run, Sprint, Kick, Tackle, Celebrate) still work with the new models",
        "No missing script or missing reference warnings appear in the console",
        "Character meshes are low-poly (fewer than 2000 triangles per model) for optimal performance on macOS and iPad",
        "Team color is applied via MaterialPropertyBlock to avoid breaking GPU instancing",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 44,
      "passes": true,
      "notes": "Download Quaternius free low-poly character pack. Import FBX files into Assets/Models/Characters/. Configure import settings: Rig tab -> Animation Type: Humanoid, Avatar Definition: Create From This Model. Create HumanoidSetup : MonoBehaviour to apply team materials. Use MaterialPropertyBlock: var mpb = new MaterialPropertyBlock(); renderer.GetPropertyBlock(mpb); mpb.SetColor('_BaseColor', teamColor); renderer.SetPropertyBlock(mpb). Verify avatar IsValid(). Replace capsule MeshFilter with model MeshFilter reference.",
      "dependsOn": ["US-019"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-044'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-045",
      "title": "Mixamo soccer animation integration",
      "description": "As a player, I want realistic soccer animations so that player movement and actions look natural and professional.",
      "acceptanceCriteria": [
        "Soccer Idle animation is imported and assigned to the Idle state in the Animator Controller",
        "Run animation is imported and assigned to the Run state",
        "Sprint animation is imported and assigned to the Sprint state",
        "Kick animation is imported and assigned to the Kick state",
        "Slide Tackle animation is imported and assigned to the Tackle state",
        "Goalkeeper Dive animation is imported and assigned to the GK Dive state",
        "All animations are retargeted to the Quaternius humanoid avatar via Unity's retargeting system",
        "All animation state machine tests from US-019 still pass with the new clips",
        "Animation transitions are smooth with no visible popping or foot sliding",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 45,
      "passes": true,
      "notes": "Download from Mixamo: Soccer Idle, Running, Sprinting, Soccer Kick (or Kicking), Slide Tackle, Goalkeeper Dive. Export as FBX for Unity, without skin (use existing model). Import settings: Rig -> Humanoid, Animation -> Loop Time for locomotion clips, no Loop for actions. Retarget: use Avatar from Quaternius model as source. Update AnimatorController: replace placeholder clips in each state. Adjust transition conditions if clip lengths differ. Root motion: disable for locomotion (use script-driven movement), enable only if needed for tackle slide.",
      "dependsOn": ["US-044"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-045'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-046",
      "title": "Stadium environment with skybox and goal posts",
      "description": "As a player, I want a stadium environment with skybox, textured pitch, goal posts, and stands so that the game feels like a real soccer match.",
      "acceptanceCriteria": [
        "A Poly Haven stadium HDRI is applied as the scene skybox material",
        "Pitch surface uses a textured material with visible mowed grass bands (alternating stripe pattern)",
        "3D goal post meshes exist at both ends of the pitch with correct dimensions matching PitchConfig.goalWidth",
        "Goal nets are represented by mesh geometry with a semi-transparent material",
        "Goal posts have MeshColliders that correctly deflect the ball",
        "Basic sideline and stands geometry exists around the pitch perimeter",
        "A screenshot is captured via ScreenCapture.CaptureScreenshot for visual baseline reference",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 46,
      "passes": true,
      "notes": "Download HDRI from Poly Haven (e.g., kloppenheim stadium). Create skybox material: Shader = Skybox/Cubemap or Skybox/Panoramic, assign HDRI texture. Pitch texture: create tiled grass texture with alternating bands via UV offset or shader. Goal posts: create from primitives (cylinders for posts, crossbar) or import mesh. Net: use a plane mesh with alpha-cutout material. MeshCollider on posts (convex=true for dynamic collision). Stands: simple extruded shapes or low-poly bleacher meshes. Use ProBuilder for quick geometry.",
      "dependsOn": ["US-002"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-046'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-047",
      "title": "Soccer ball 3D model with PBR material",
      "description": "As a player, I want a realistic-looking soccer ball model so that the game feels polished and professional.",
      "acceptanceCriteria": [
        "A 3D soccer ball model replaces the primitive sphere for the Ball GameObject",
        "PBR material is applied with albedo (color), normal map, and roughness/smoothness textures",
        "Ball mesh rotates correctly when rolling (angular velocity matches visual rotation)",
        "Ball SphereCollider radius matches the visual mesh bounds",
        "All existing ball physics tests (US-003) still pass with the new model",
        "Ball model polygon count is under 1000 triangles for mobile performance",
        "No missing material or texture warnings in the console",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 47,
      "passes": true,
      "notes": "Source a free soccer ball model (Sketchfab CC0 or create with Blender). Import FBX into Assets/Models/Ball/. Material: URP Lit shader, assign albedo (classic black/white pentagon pattern), normal map for panel seams, smoothness ~0.4 for slight sheen. Ensure mesh pivot is at center for correct rotation. SphereCollider: adjust radius to match mesh bounds.extents.x. Visual rotation handled by Rigidbody angular velocity automatically if mesh is on the Rigidbody GameObject. Verify: ball.GetComponent<MeshFilter>().sharedMesh.triangles.Length / 3 < 1000.",
      "dependsOn": ["US-003"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-047'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-048",
      "title": "Real audio asset integration",
      "description": "As a player, I want real sound effects replacing placeholder audio so that the game sounds professional and immersive.",
      "acceptanceCriteria": [
        "A real whistle sound effect (CC0/Freesound sourced) replaces the placeholder whistle clip",
        "At least 3 kick impact sound variations are imported for random selection on ball strikes",
        "A crowd ambient loop is imported and plays continuously during matches",
        "A goal celebration cheer sound is imported and plays on goal events",
        "All AudioSource clip references are valid (not null) across all relevant components",
        "No 'missing AudioClip' warnings appear in the console during gameplay",
        "AudioClips are compressed appropriately for mobile (Vorbis/AAC, quality 70%)",
        "SoundManager randomly selects from kick variations on each kick event",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 48,
      "passes": true,
      "notes": "Source from Freesound.org (CC0 license): search 'referee whistle', 'soccer kick', 'crowd cheer', 'stadium ambience'. Import as AudioClip. Import settings: Force To Mono for SFX, Compression Format Vorbis, Quality 70, Load Type 'Decompress On Load' for short SFX, 'Streaming' for ambient loop. SoundManager: AudioClip[] kickClips; PlayKick() { PlayOneShot(kickClips[Random.Range(0, kickClips.Length)]); }. Verify: Assert.IsNotNull(soundManager.whistleClip) etc. in test.",
      "dependsOn": ["US-023"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-048'"],
      "estimatedScope": "small"
    },
    {
      "id": "US-049",
      "title": "Visual regression baseline screenshots",
      "description": "As a developer, I want golden screenshot baselines captured at key moments so that visual regressions can be detected automatically.",
      "acceptanceCriteria": [
        "Golden screenshots are captured at 3 camera checkpoints: Kickoff view, GoalCloseup view, CornerFlag view",
        "A comparison test infrastructure exists that compares current screenshots against baselines",
        "Pixel difference between current and baseline must be less than 2% for the test to pass",
        "Baseline screenshot files are committed to the repository under a known path (e.g., Tests/Baselines/)",
        "VisualRegressionTest class provides a CompareScreenshot(string baselineName) method",
        "Screenshots are captured at a fixed resolution (1920x1080) for consistency",
        "The comparison algorithm accounts for minor anti-aliasing differences",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 49,
      "passes": true,
      "notes": "Create VisualRegressionTest in PlayMode test assembly. Use ScreenCapture.CaptureScreenshotAsTexture() at fixed resolution via Screen.SetResolution. Compare: read baseline from Resources or StreamingAssets, get pixel arrays via Texture2D.GetPixels32(), iterate and count differing pixels (threshold per-channel diff > 10). Diff percentage = diffPixels / totalPixels. Camera checkpoints: position camera at predefined transforms, wait one frame, capture. Store baselines in Assets/Tests/Baselines/. Use [Category('Visual')].",
      "dependsOn": ["US-044", "US-045", "US-046", "US-047", "US-048"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-049'"],
      "estimatedScope": "medium"
    },
    {
      "id": "US-050",
      "title": "Local multiplayer on same device via split touch zones",
      "description": "As two players sharing one device, I want split-screen touch controls so that we can play against each other locally.",
      "acceptanceCriteria": [
        "Two virtual joystick zones are defined: left half for Player 1, right half for Player 2",
        "Each joystick zone controls one team's active player independently",
        "Both touch inputs work simultaneously via multi-touch support",
        "A match can be played with two human-controlled players (one per team)",
        "AI fills the remaining 4 positions on each team (8 AI total)",
        "Player 1 action buttons appear in the center-left area, Player 2 in center-right area",
        "No input cross-talk occurs between the two player zones",
        "LocalMultiplayerManager exposes Player1Input and Player2Input vectors for test verification",
        "All existing tests still pass",
        "Unity build completes with zero errors"
      ],
      "priority": 50,
      "passes": true,
      "notes": "Create LocalMultiplayerManager : MonoBehaviour. Split screen into left/right halves. Track Touch.fingerId to separate inputs. Player 1: touches with position.x < Screen.width/2. Player 2: touches with position.x >= Screen.width/2. Each player gets own VirtualJoystick instance with zone restriction. Use EnhancedTouch API from Input System: EnhancedTouchSupport.Enable(), Touch.activeTouches. Create two PlayerInput components or two instances of input provider. Action buttons: duplicate ActionButtons prefab for each side. Ensure InputSystem multitouch is enabled.",
      "dependsOn": ["US-036", "US-037"],
      "testCommands": ["unity -runTests -batchmode -nographics -testCategory 'US-050'"],
      "estimatedScope": "large"
    }
  ]
}
